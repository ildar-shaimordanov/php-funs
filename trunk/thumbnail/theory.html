<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en" dir="ltr">

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
<title>Thumbnails: Теория и практика создания миниатюрных изображений</title>
<link rel="stylesheet" href="files/styles.css" type="text/css" />
</head>
<body>

<h1>Thumbnails: Теория и практика создания миниатюрных изображений</h1>

<div id="TOC">
<a name="TOP"></a>

<h2>Содержание</h2>

<ul>
<li><a href="#INTRODUCTION">Введение</a>
	<ul>
	<li><a href="#INTRODUCTION-NOTATION">Обозначения, принятые в статье</a></li>
	</ul>
	</li>
<li><a href="#METHOD">Методы создания миниатюр</a>
	<ul>
	<li><a href="#METHOD-SQUEEZE-MAX">Метод максимального сжатия</a></li>
	<li><a href="#METHOD-FRAGMENT">Фрагмент целого</a></li>
	<li><a href="#METHOD-SQUEEZE-MAX">Метод минимального сжатия</a></li>
	<li><a href="#METHOD-PERCENTAGE">Пропорциональное сжатие в процентах</a></li>
	</ul>
	</li>
<li><a href="#ILLUSTRATION">Иллюстрация создания миниатюр на PHP</a>
	<ul>
	<li><a href="#ILLUSTRATION-OPTIONS">Опции обработки изображения</a></li>
	<li><a href="#ILLUSTRATION-ERRORS">Обработка ошибок</a></li>
	<li><a href="#ILLUSTRATION-ADDS">Вспомогательные методы</a></li>
	<li><a href="#ILLUSTRATION-CONSTANTS">Предопределенные константы класса</a></li>
	<li><a id="EXAMPLE" href="#ILLUSTRATION-EXAMPLES">Примеры использования</a></li>
	</ul>
	</li>
<li><a href="#CONCLUSION">Заключение</a></li>
</ul>

</div>
<div id="BODY">


<a name="INTRODUCTION"></a>
<h2>Введение </h2>
<p>Интернет позволяет пользователям публиковать собственные графические изображения, например, созданные с помощью компьютера, или фотографии, выполненные цифровыми камерами. Чаще всего эти работы выполнены на высоком художественном уровне и такие файлы значительны по размеру (как геометрически, так и в объеме хранимой информации). Современные серверные технологии позволяют создать уменьшенные копии изображений для их предварительного просмотра. </p>
<p>В англоязычной литературе для обозначения уменьшенных копий оригиналов существуют два термина - preview и thumbnail. Ни одно их не имеет адекватного перевода в русскоязычной литературе кроме более близкого по смыслу термина - миниатюра. В дальнейшем, в данной статье будет использоваться именно это слово и производные от него (с целью исключения повторов в тексте) либо близкие по смыслу выражения. </p>


<a name="INTRODUCTION-NOTATION"></a>
<h3>Обозначения, принятые в статье </h3>
<p>Все способы создания миниатюр предполагают выполнение предварительных арифметических операций для вычисления начальной точки копирования фрагмента оригинального изображения, размеров копируемой области. На протяжении данной работы будут использоваться следующие обозначения (выраженные в пикселях): </p>
<ul>
<li><code>W</code>, <code>H</code> - ширина и высота оригинального изображения, соответственно; </li>
<li><code>X</code>, <code>Y</code> - координаты начальной точки копирования (левого верхнего угла); </li>
<li><code>width</code>, <code>height</code> - ширина и высота миниатюры, соответственно; </li>
<li><code>R</code>, <code>ratio</code> - отношения меньшей стороны к большей стороне прямоугольников оригинала и миниатюры, соответственно;</li>
<li><code>Ww</code> - отношение ширины большого прямоугольника к ширине маленького; </li>
<li><code>Hh</code> - отношение высоты большого прямоугольника к ширине маленького. </li>
</ul>


<a name="METHOD"></a>
<h2>Методы создания миниатюр </h2>
<p>Основное место использования миниатюр - тематически структурированные коллекции и фото-галереи, где на главных страницах разделов выводятся уменьшенные копии изображений со ссылкой на оригинал. Для более подробного ознакомления с работой пользователь может посмотреть полную версию оригинала. </p>
<p>Размер миниатюры устанавливается администратором фото-галереи и имеет фиксированный размер, соответствующий общему дизайну. В настоящее время существует два наиболее распространенных способа создания миниатюр: </p>
<ul>
<li>пропорционально уменьшенная копия; </li>
<li>вырезание некоторого фрагмента оригинала. </li>
</ul>
<p>Каждый из способов имеет свои достоинства и недостатки. Например, миниатюры, созданные по первому способу позволяют увидеть миниатюрную копию цельного изображения, но могут испортить общий дизайн вследствие различной ориентации изображений (книжная или альбомная). А второй способ не дает полного представления о представленном изображении. </p>
<p>Однако можно выделить еще один, третий способ создания миниатюр, который можно представить как комбинацию первых двух. В данной статье будут рассмотрены все возможные способы. </p>
<p>Дополнительно, в противовес традиционным методам создания миниатюрных копий фиксированного размера, выраженного в пикселях, будет рассмотрено пропорциональное сжатие, выраженное в процентах от геометрического размера оригинального изображения. Будет показано, что этот способ не может рассматриваться как полноценный метод создания миниатюр, но имеет право на существование в определенных случаях. </p>
<p>По-видимому, не существует терминов, обозначающих способы создания миниатюр (по крайней мере, автор статьи их не обнаружил, кроме существующих терминов - масштабирование и обрезка), поэтому в статье будет использовать собственные. Эта терминология не претендует быть общепринятой, однако если это случится - автор будет рад. </p>


<a name="METHOD-SQUEEZE-MAX"></a>
<h3>Метод максимального сжатия </h3>
<p>Используемый термин метод максимального сжатия означает сжатие большей стороны оригинала, так чтобы он был вписан полностью в размеры предлагаемой миниатюры. Для этого необходимо:</p>
<ul>
<li>определить большую сторону прямоугольника первоначального изображения; </li>
<li>вычислить отношение <code>R</code>; </li>
<li>вычислить меньшую сторону прямоугольника миниатюры путем умножения отношения <code>R</code> и большей стороны. </li>
</ul>
<p>На псевдокоде это будет описано так: </p>
<pre>
if W &gt; H
then
    height = H * width / W
else
    width  = W * height / H
end if
</pre>
<p>Таким образом, будут определены размеры будущей копии. Это необходимо, для создания уменьшенной копии, которая будет вписана в заданные рамки миниатюры без искажений. Дальнейшие действия заключаются в использовании соответствующих графических средств на стороне сервера по преобразованию изображений. Следующий пример иллюстрирует преобразование, реализованное на PHP (в предположении, что исходное изображение уже загружено в программу - переменная <code>$srcImage</code>, и его размеры получены в <code>$width</code> и <code>$height</code>): </p>
<pre>
$dstImage = imagecreate($width, $height);
imagecopyresized(
    $dstImage, $srcImage,
    0, 0, 0, 0,
    $width, $height, $W, $H);
</pre>
<p>Описание данного метода завершим рисунком, иллюстрирующим данный подход. </p>

<p><b>Рисунок 1. Метод максимального сжатия </b></p>
<img src="files/illustration-squeeze_max.png" />


<a name="METHOD-FRAGMENT"></a>
<h3>Фрагмент целого </h3>
<p>Вырезать фрагмент технически достаточно простой способ - все-таки вся работа заключается лишь в копирования части изображения. Однако эстетическая сторона явно не соблюдена. В лучшем случае, если программистом заложена возможность - позволить пользователям выбрать подходящий фрагмент для показа на миниатюре. В худшем - будет создана копия, например, центральной части. Тем не менее техническую сторону мы рассмотрим. Так же рассмотрим вариант выбора фрагмента. </p>
<p>Следующий код на PHP иллюстрирует данный подход: </p>
<pre>
$dstImage = imagecreate($width, $height);
imagecopy(
    $dstImage, $srcImage
    0, 0, $X, $Y,
    $width, $height);
</pre>
<p>При всем многообразии начальных координат источника копирования автор считает, что источник копии может иметь только девять фиксированных позиций: </p>
<ol>
<li>центральная; </li>
<li>крайние левая и правая стороны; </li>
<li>крайние верхняя и нижняя границы; </li>
<li>углы прямоугольника. </li>
</ol>
<p>Соответственно, можно говорить о вертикальном и горизонтальном выравнивании. Алгоритм вычисления координат источника описан на псевдокоде: </p>
<pre>
if horizontal align = left
then
    X = 0
else if horizontal align = right
    X = W - width
else
    X = (W - width) / 2
end if

if vertical align = top
then
    Y = 0
else if vertical align = bottom
    Y = H - height
else
    Y = (H - height) / 2
end if
</pre>

<p><b>Рисунок 2. Фрагмент целого </b></p>
<img src="files/illustration-fragment.png" />
 

<a name="METHOD-SQUEEZE-MIN"></a>
<h3>Метод минимального сжатия </h3>
<p>Рассмотрим вертикально расположенное изображение, которое необходимо вписать в квадрат. Если метод максимального сжатия, предполагает, что необходимо сжать большую сторону на столько, чтобы она полностью была вписана в соответствующую сторону миниатюры, то для реализации этого метода необходимо сжать меньшую, чтобы добиться требуемого результата. </p>

<p><b>Рисунок 3. Метод минимального сжатия </b></p>
<img src="files/illustration-squeeze_min.png" />

<p>В общем случае, одна из сторон большого прямоугольника должна быть вписана в соответствующую сторону малого. При этом коэффициент сжатия (масштабирования) должен быть минимален. Этого легко добиться сравнивая соотношения соответствующих сторон - большее соотношение определяет сторону, которое будет обрезано при масштабировании. </p>
<pre>
Ww = W / width
Hh = H / height
if Ww &gt; Hh
then
    W = width * Hh
    X = ...
else
    H = height * Ww
    Y = ...
end if
</pre>
<p>Здесь используется алгоритм вычисления начальных координат источника фрагмента, идентичный описанному ранее алгоритму. </p>
<p>Так как одна из сторон большего прямоугольника будет полностью вписана в соответствующую сторону меньшего, а другая - обрезана, то здесь тоже можно говорить о выравнивании - или вертикальном, или горизонтальном. </p>


<a name="METHOD-PERCENTAGE"></a>
<h3>Пропорциональное сжатие в процентах </h3>
<p>Последний способ создания миниатюр сложно отнести к действительно полноценному методу, однако он тоже требует своего рассмотрения. Причина кроется в том что, это фактически метод максимального сжатия и метод вырезания фрагмента целого, выраженные в пропорциональном уменьшении геометрических размеров изображения, но выраженное в процентах. Этот способ логично использовать в двух случаях: </p>
<ul>
<li>в проектах, где жестко заданы размеры исходного изображения (фиксированная ширина и/или фиксированная высота); </li>
<li>при преобразовании очень больших изображений, когда создание миниатюры в один проход может привести к переполнению памяти.</li>
</ul>
<p>При этом следует иметь в виду, что пропорции относятся к соответствующим сторонам исходного изображения и результирующего. </p>


<a name="ILLUSTRATION"></a>
<h2>Иллюстрация создания миниатюр на PHP </h2>
<p>В этом разделе будет подробно рассмотрен реализованный на PHP в рамках объектно-ориентированного похода модуль <code>Thumbnail</code> на основе описанного алгоритма. </p>
<p>Основным публичным методом является метод <code>output()</code>. В своей работе он использует результат работы метода <code>render()</code>, определяет приемник для вывода изображения (браузер или файл на сервере): </p>
<pre>
function output($input, $output=null, $options=array())
{
    // Load source file and render image
    $renderImage = Thumbnail::render($input, $options);
    if ( ! $renderImage ) {
        user_error('Error rendering image', 
            E_USER_NOTICE);
        return false;
    }

    // Set output image type
    // By default PNG image
    $type = isset($options['type']) ? $options['type'] : IMAGETYPE_PNG;

    // Before output to browsers send appropriate headers
    if ( empty($output) ) {
        $content_type = image_type_to_mime_type($type);
        if ( ! headers_sent() ) {
            header('Content-Type: ' . $content_type);
        } else {
            user_error('Headers have already been sent. Could not display image.', 
                E_USER_NOTICE);
            return false;
        }
    }

    // Define outputing function
    switch ($type) {
    case IMAGETYPE_PNG:
        $result = empty($output) 
            ? imagepng($renderImage) 
            : imagepng($renderImage, $output);
        break;
    case IMAGETYPE_JPEG:
        $result = empty($output) 
            ? imagejpeg($renderImage) 
            : imagejpeg($renderImage, $output);
        break;
    default:
        user_error('Image type ' . $content_type . ' not supported by PHP', 
            E_USER_NOTICE);
        return false;
    }

    // Output image (to browser or to file)
    if ( ! $result ) {
        user_error('Error output image', 
            E_USER_NOTICE);
        return false;
    }

    // Free a memory from the target image
    imagedestroy($renderImage);

    return true;
}
</pre>
<p>Обязательный аргумент функции - имя файла исходного изображения. По умолчанию, метод выводит результирующее изображение в браузер. Если будет указан второй аргумент - имя выходного файла, будет создан файл. Третий, аргумент метода, ассоциативный массив, содержит необязательные параметры обработки изображений. По умолчанию, используются собственные установки - методом максимального сжатия создается миниатюра в формате <code>PNG</code> размером 150х150 пикселей. </p>
<p>Логика класса по созданию миниатюр реализована в методе <code>render()</code>, который загружает файл изображения в память, определяет размеры исходного изображения, рассчитывает размеры будущей миниатюрной копии, создает новое изображение и возвращает ссылку на него в случае успешного выполнения. При этом данный метод использует вспомогательные методы для загрузки объекта и расчета необходимых переменных: </p>
<pre>
function render($input, $options=array())
{
    // Create the source image
    $sourceImage = Thumbnail::imageСreate($input);
    if ( ! is_resource($sourceImage) ) {
        user_error('Invalid image resource', 
            E_USER_NOTICE);
        return false;
    }
    $sourceWidth  = imagesx($sourceImage);
    $sourceHeight = imagesy($sourceImage);

    // Set default options
    static $defOptions = array(
        'width'   => 150,
        'height'  => 150,
        'method'  => THUMBNAIL_METHOD_SCALE_MAX,
        'percent' => 0,
        'halign'  => THUMBNAIL_ALIGN_CENTER,
        'valign'  => THUMBNAIL_ALIGN_CENTER,
    );
    foreach ($defOptions as $k => $v) {
        if ( ! isset($options[$k]) ) {
            $options[$k] = $v;
        }
    }

    // Estimate a rectangular portion of the source image and a size of the target image
    if ( $options['method'] == THUMBNAIL_METHOD_CROP ) {
        if ( $options['percent'] ) {
            $W = floor($options['percent'] * $sourceWidth);
            $H = floor($options['percent'] * $sourceHeight);
        } else {
            $W = $options['width'];
            $H = $options['height'];
        }

        $width  = $W;
        $height = $H;

        $Y = Thumbnail::_coord($options['valign'], $sourceHeight, $H);
        $X = Thumbnail::_coord($options['halign'], $sourceWidth,  $W);
    } else {
        $X = 0;
        $Y = 0;

        $W = $sourceWidth;
        $H = $sourceHeight;

        if ( $options['percent'] ) {
            $width  = floor($options['percent'] * $W);
            $height = floor($options['percent'] * $H);
        } else {
            $width  = $options['width'];
            $height = $options['height'];

            if ( $options['method'] == THUMBNAIL_METHOD_SCALE_MIN ) {
                $Ww = $W / $width;
                $Hh = $H / $height;
                if ( $Ww &gt; $Hh ) {
                    $W = floor($width * $Hh);
                    $X = Thumbnail::_coord($options['halign'], $sourceWidth,  $W);
                } else {
                    $H = floor($height * $Ww);
                    $Y = Thumbnail::_coord($options['valign'], $sourceHeight, $H);
                }
            } else {
                if ( $H &gt; $W ) {
                    $width  = floor($height / $H * $W);
                } else {
                    $height = floor($width / $W * $H);
                }
            }
        }
    }

    // Create the target image
    if ( function_exists('imagecreatetruecolor') ) {
        $targetImage = imagecreatetruecolor($width, $height);
    } else {
        $targetImage = imagecreate($width, $height);
    }
    if ( ! is_resource($targetImage) ) {
        user_error('Cannot initialize new GD image stream', 
            E_USER_NOTICE);
        return false;
    }

    // Copy the source image to the target image
    if ( $options['method'] == THUMBNAIL_METHOD_CROP ) {
        $result = imagecopy(
            $targetImage, $sourceImage, 
            0, 0, $X, $Y, 
            $W, $H);
    } elseif ( function_exists('imagecopyresampled') ) {
        $result = imagecopyresampled(
            $targetImage, $sourceImage, 
            0, 0, $X, $Y, 
            $width, $height, $W, $H);
    } else {
        $result = imagecopyresized(
            $targetImage, $sourceImage, 
            0, 0, $X, $Y, 
            $width, $height, $W, $H);
    }
    if ( ! $result ) {
        user_error('Cannot resize image', 
            E_USER_NOTICE);
        return false;
    }

    // Free a memory from the source image
    imagedestroy($sourceImage);

    // Save the resulting thumbnail
    return $targetImage;
}
</pre>
<p>Данный метод учитывает особенности работы PHP с графическими изображениями - при отсутствии функций библиотеки GD для работы с изображениями высокого качества <code>imagecreatetruecolor</code> и <code>imagecopyresampled</code> используются их менее качественные аналоги <code>imagecreate</code> и <code>imagecopyresized</code>. </p>


<a name="ILLUSTRATION-OPTIONS"></a>
<h3>Опции обработки изображения </h3>
<p>При необходимости, можно указать аргумент <code>$options</code> (ассоциативный массив параметров - третий аргумент метода <code>output()</code> и второй - метода <code>render()</code>) для реализации собственной обработки изображений. Для этого необходимо лишь указать требуемые опции </p>
<ul>
<li><code>width</code> - ширина миниатюры в пикселях (целое положительное число, по умолчанию 150); </li>
<li><code>height</code> - высота миниатюры в пикселях (целое положительное число, по умолчанию 150); </li>
<li><code>method</code> - метод обработки - максимальное/минимальное сжатие, вырезание фрагмента целого(целое число, по умолчанию максимальное сжатие); </li>
<li><code>percent</code> - масштабирование в процентах от оригинала (положительное вещественное число на интервале от 0 до 1, по умолчанию 0); </li>
<li><code>halign</code> - вертикальное выравнивание (допустимые значения 0 - по центру, &lt; 0 - выравнивание по верхнему краю, &gt; 0 - выравнивание по нижнему краю, по умолчанию - 0); </li>
<li><code>valign</code> - горизонтальное выравнивание (допустимые значения 0 - по центру, &lt; 0 - выравнивание влево, &gt; 0 - выравнивание вправо, по умолчанию - 0); </li>
<li><code>type</code> - тип выводимого изображения (<code>IMAGETYPE_PNG</code> или <code>IMAGETYPE_JPEG</code>, по умолчанию - <code>IMAGETYPE_PNG</code>). </li>
</ul>


<a name="ILLUSTRATION-ERRORS"></a>
<h3>Обработка ошибок </h3>
<p>Никто не застрахован от ошибок, поэтому модуль реализует минимальную обработку типовых ошибок (неверный формат входных данных, невозможность инициализации графического формата) посредством генерации пользовательских сообщений встроенной функцией <code>user_error</code>. </p>
<p>Ошибки передачи некорректных опций отсутствуют. По мнению автора, эти ошибки должны обрабатываться и корректироваться на уровне приложения до передачи их в модуль. </p>


<a name="ILLUSTRATION-ADDS"></a>
<h3>Вспомогательные методы </h3>
<p>Эти методы необходимы для загрузки изображения и расчета координат и размеров области копирования исходного и результирующего изображений. </p>
<p>Методы загрузки изображения из файла - основное их назначение определить источник изображения (файл, строка или образ изображения в памяти) </p>
<pre>
function imageCreate($input)
{
    if ( is_file($input) ) {
        return Thumbnail::imageCreateFromFile($input);
    } else if ( is_string($input) ) {
        return Thumbnail::imageCreateFromString($input);
    } else {
        return $input;
    }
}

function imageCreateFromFile($filename)
{
    if ( ! is_file($filename) || ! is_readable($filename) ) {
        user_error('Unable to open file "' . $filename . '"', 
            E_USER_NOTICE);
        return false;
    }

    // determine image format
    list( , , $type) = getimagesize($filename);

    switch ($type) {
    case IMAGETYPE_JPEG:
        return imagecreatefromjpeg($filename);
        break;
    case IMAGETYPE_PNG:
        return imagecreatefrompng($filename);
        break;
    }
    user_error('Unsupport image type', E_USER_NOTICE);
    return false;
}

function imageCreateFromString($string)
{
    if ( ! is_string($string) || empty($string) ) {
        user_error('Invalid image value in string', 
            E_USER_NOTICE);
        return false;
    }

    return imagecreatefromstring($string);
}
</pre>
<p>Метод расчета координат и размеров области копирования исходного и результирующего изображений</p>
<pre>
function _coord($align, $param, $src)
{
    if ( $align &lt; THUMBNAIL_ALIGN_CENTER ) {
        $result = 0;
    } elseif ( $align &gt; THUMBNAIL_ALIGN_CENTER ) {
        $result = $param - $src;
    } else {
        $result = ($param - $src) >> 1;
    }
    return $result;
}
</pre>
<p>Вся логика класса реализована в методе <code>render()</code>, который загружает файл изображения в память, определяет размеры исходного изображения, рассчитывает размеры будущей миниатюрной копии и возвращает ссылку на новое изображение в случае успешного выполнения. При этом данный метод использует вспомогательные методы для загрузки объекта и расчета необходимых переменных: </p>


<a name="ILLUSTRATION-CONSTANTS"></a>
<h3>Предопределенные константы класса </h3>
<p>В модуле предопределено несколько констант для управления методом создания миниатюр и выравнивания изображений </p>
<pre>
/**
 * Maximal scaling
 */
define('THUMBNAIL_METHOD_SCALE_MAX', 0);

/**
 * Minimal scaling
 */
define('THUMBNAIL_METHOD_SCALE_MIN', 1);

/**
 * Cropping of fragment
 */
define('THUMBNAIL_METHOD_CROP',      2);

/**
 * Align constants
 */
define('THUMBNAIL_ALIGN_CENTER', 0);
define('THUMBNAIL_ALIGN_LEFT',   -1);
define('THUMBNAIL_ALIGN_RIGHT',  +1);
define('THUMBNAIL_ALIGN_TOP',    -1);
define('THUMBNAIL_ALIGN_BOTTOM', +1);
</pre>


<a name="ILLUSTRATION-EXAMPLES"></a>
<h3>Примеры использования </h3>
<p><b>Пример 1. <a href="demo1.php">Простое создание миниатюры в браузер</a> </b></p>
<pre>
include_once 'includes/Thumbnail.php';

$filename = 'files/image.jpg';
Thumbnail::output($filename); 
</pre>

<p><b>Пример 2. Простое создание миниатюры в файл </b></p>
<pre>
include_once 'includes/Thumbnail.php';

$input_file = 'files/image.jpg';
$output_file = 'files/thumb.jpg';
Thumbnail::output($input_file, $output_file); 
</pre>

<p><b>Пример 3. <a href="demo3.php">Использование собственных параметров (JPEG, 200х200 пикселей)</a> </b></p>
<pre>
include_once 'includes/Thumbnail.php';

$filename = 'files/image.jpg';
$options = array(
    'width'  => 200,
    'height' => 200,
    'type'   => IMAGETYPE_JPEG,
);
Thumbnail::output($filename, null, $options);
</pre>
<p>По умолчанию, из любого изображения создается маленькое изображение в формате <code>PNG</code>. Указывая явно тип можно изменить формат графического потока (в примере - <code>JPEG</code>). Для вывода в браузер второй аргумент установлен в значение <code>null</code>. </p>

<p><b>Пример 4. <a href="demo4.php">Каскадное создание миниатюры из очень большого изображения</a></b></p>
<pre>
include_once 'includes/Thumbnail.php';

$filename = 'files/image.jpg';
$middleImage = Thumbnail::render($filename, array(
    'percent' => 0.5,
    'method'  => THUMBNAIL_METHOD_CROP,
));

Thumbnail::output($middleImage);
</pre>
<p>Последний пример стоит разобрать более подробно. </p>
<p>Вначале из исходного изображения вырезается центральный прямоугольник, стороны которого составляют ровно половину оригинала (50%). Затем, за второй проход из полученного промежуточного изображения создается обычная уменьшенная копия (стандартные размеры 150х150 пикселей). После этого полученное окончательное изображение отображается в браузере. </p>

<p><b>Пример 5. <a href="demo5.php">Сложный пример формы управления созданием миниатюры</a></b></p>

<a name="CONCLUSION"></a>
<h2>Заключение </h2>
<p>Хотя задача создания миниатюр не самая сложная задача, решаемая разработчиками интернет-приложений, тем не менее, она не всегда решается на должном уровне и в полном объеме. В настоящей статье были разобраны все варианты создания миниатюр, кратко рассмотрены особенности работы с изображениями в PHP. </p>
<p>Методы загрузки и создания реализуют работу с изображениями только в форматах <code>PNG</code> и <code>JPEG</code>. Однако модуль расширяем, и добавить отсутствующую функциональность будет достаточно легко. </p>
<p>Как ни странно, но в богатой коллекции PEAR нет полноценных классов или методов для работы с миниатюрами, хотя существуют пакеты, реализующие отдельные методы обработки изображений (обрезки, масштабирования, поворота и т.д.) Однако описанный модуль может быть с легкостью интегрирован. </p>
<p>Исходные коды и демонстрационные файлы представлены в архиве по адресу <a href="http://phpmrtgadmin.sourceforge.net/download/demo/thumbnail/thumbnail.zip">http://phpmrtgadmin.sourceforge.net/download/demo/thumbnail/thumbnail.zip</a>. </p>

<p id="COPYRIGHT">
Ильдар Шайморданов, <a href="mailto:phpmrtgadmin@user.sourceforge.net">phpmrtgadmin@user.sourceforge.net</a><br />
</p>

</div>

</body>
</html>

